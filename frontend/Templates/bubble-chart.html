<!DOCTYPE html>

<div class="chart-example" id="chart"><svg></svg></div>

<p>
  <label for="year"
         style="display: inline-block; width: 240px; text-align: right">
         year = <span id="year-value">â€¦</span>
  </label>
  <input type="range" min="2000" max="2001" id="year">
</p>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.6.0/d3.min.js"></script>

<script>

d3.csv("{{url_for('static', filename = 'medium_january.csv')}}", function(error, data) {
  if (error) {
      console.error('Error getting or parsing the data.');
      throw error;
  }
  // selection.datum() returns the bound datum for the first element in the selection and
  //  doesn't join the specified array of data with the selected elements
  var chart = bubbleChart().width(600).height(400);
  d3.select('#chart').datum(data).call(chart);
});

function bubbleChart() {

  // when the slider value changes call the update function to change node sizes
  d3.select("#year").on("input", function() {
    update(+this.value);
  });

  // use the year to get the column/index of data file that contains the radius data for the nodes
  function getRadiusCol(year) {
    year_index = year - 1999;
    index = year_index.toString();
    return index;
  }

  // Initial the nodes with data from the year 2000
  update(2000);

  // must not be updating the columnForRadiust

  var width = 960,
      height = 960,
      maxRadius = 6,
      columnForColors = "category",
      // this is the line that needs to update when the slider updates
      //columnForRadius = "1"
      //columnForRadius = getRadiusCol(2001);
      columnForRadius = dataIndex;

  // update things based on what year the slider is set to
  function update(year) {

    // adjust the text on the range slider
    d3.select("#year-value").text(year);
    d3.select("#year").property("value", year);

    // update the circle radius
    dataIndex = getRadiusCol(year);
    columnForRadius = dataIndex;
    //bubbleChart(dataIndex);
  }

  function chart(selection) {
      var data = selection.datum();
      var div = selection,
          svg = div.selectAll('svg');
      svg.attr('width', width).attr('height', height);

      var tooltip = selection
          .append("div")
          .style("position", "absolute")
          .style("visibility", "hidden")
          .style("color", "white")
          .style("padding", "8px")
          .style("background-color", "#626D71")
          .style("border-radius", "6px")
          .style("text-align", "center")
          .style("font-family", "monospace")
          .style("width", "400px")
          .text("");


      var simulation = d3.forceSimulation(data)
          .force("charge", d3.forceManyBody().strength([-50]))
          .force("x", d3.forceX())
          .force("y", d3.forceY())
          .on("tick", ticked);

      function ticked(e) {
          node.attr("cx", function(d) {
                  return d.x;
              })
              .attr("cy", function(d) {
                  return d.y;
              });
      }

      var colorCircles = d3.scaleOrdinal(d3.schemeCategory10);
      var scaleRadius = d3.scaleLinear().domain([d3.min(data, function(d) {
          return +d[columnForRadius];
      }), d3.max(data, function(d) {
          return +d[columnForRadius];
      })]).range([5, 18])

      var node = svg.selectAll("circle")
          .data(data)
          .enter()
          .append("circle")
          // This is the line that sets the radius -> how can we use transition to redo the transition
          .attr('r', function(d) {
              return scaleRadius(d[columnForRadius])
          })
          .style("fill", function(d) {
              return colorCircles(d[columnForColors])
          })
          .attr('transform', 'translate(' + [width / 2, height / 2] + ')')
          .on("mouseover", function(d) {
              tooltip.html(d[columnForColors] + "<br>" + d.title + "<br>" + d[columnForRadius] + " hearts");
              return tooltip.style("visibility", "visible");
          })
          .on("mousemove", function() {
              return tooltip.style("top", (d3.event.pageY - 10) + "px").style("left", (d3.event.pageX + 10) + "px");
          })
          .on("mouseout", function() {
              return tooltip.style("visibility", "hidden");
          });
  }

  chart.width = function(value) {
      if (!arguments.length) {
          return width;
      }
      width = value;
      return chart;
  };

  chart.height = function(value) {
      if (!arguments.length) {
          return height;
      }
      height = value;
      return chart;
  };


  chart.columnForColors = function(value) {
      if (!arguments.columnForColors) {
          return columnForColors;
      }
      columnForColors = value;
      return chart;
  };

  chart.columnForRadius = function(value) {
      if (!arguments.columnForRadius) {
          return columnForRadius;
      }
      columnForRadius = value;
      return chart;
  };

  return chart;
}


</script>
